#' Construct a Makefile
#'
#' This function constructs a \code{Makefile} for a package web.
#'
#' @param web The web to construct the \code{Makefile} for
#' @param target_dir Target directory for \code{Makefile}, default: the web's root
#'   directory
#' @param lib_dir Library directory for installation, default: User library
#' @return A Makefile
#'
#' @importFrom MakefileR make_rule make_def make_group make_comment make_text
#' @export
makify <- function(web = rpkgweb(), target_dir = NULL, lib_dir = NULL) {
  web <- as.rpkgweb(web)

  target_dir <- get_target_dir(web, target_dir)

  target_dir_rel <- R.utils::getRelativePath(target_dir, root_dir(web))
  if (grepl("^[.][.]", target_dir_rel)) {
    stop("target_dir must reside inside the web.", call. = FALSE)
  }

  root_dir_rel <- R.utils::getRelativePath(root_dir(web), target_dir)

  if (is.null(lib_dir)) {
    lib_dir <- .libPaths()[[1L]]
    lib_export <- FALSE
  } else {
    lib_export <- TRUE
  }

  # Local definitions
  check_dir <- "rpkgweb-check"
  check_log_path <- . %>% sprintf("%s.Rcheck", .) %>% file.path(check_dir, ., "00check.log")
  code_desc_path <- . %>% file.path(root_dir_rel, ., "DESCRIPTION")

  check_dir_create_call <-
    "dir.create('{{{ check_dir }}}', showWarnings = FALSE, recursive = TRUE)" %>%
    whisker::whisker.render()

  run_check_call <-
    "devtools::check('$(patsubst %/,%,$(dir $<))', cleanup = FALSE, check_dir = '{{{ check_dir }}}')" %>%
    whisker::whisker.render()
  # End local definitions

    g <- make_group(make_comment("Autogenerated using rpkgweb"), sep = "")
  if (Sys.getenv("RPKGWEB_QUALIFY") != "")
    g <- g +
      make_group(
        make_comment("Use alternative loading method for rpkgweb library"),
        make_def("RPKGWEB_QUALIFY", Sys.getenv("RPKGWEB_QUALIFY")),
        make_text("export RPKGWEB_QUALIFY")
      )
  g +
    make_group(
      make_comment("Web"),
      make_def("RPKGWEB_ROOT_DIR", root_dir_rel)
    ) +
    make_def("R_USER_LIBRARY", .libPaths()[[1L]]) +
    make_group(
      make_comment("Universal targets"),
      make_rule("all", "all-install"),
      make_rule("all-install", web %>% names),
      make_rule("all-check", sprintf("check-%s", web %>% names))
    ) +
    make_rule(".FORCE") +
    make_rule("Makefile", ".FORCE",
              "write_makefile(web = '${RPKGWEB_ROOT_DIR}', target_dir='.')" %>%
                .rpkgweb_qualify() %>% Rscript_call()) +
    make_rule(lib_desc_path("%"), code_desc_path("%"),
              "check_up('$(patsubst %/,%,$(dir $<))', web = '${RPKGWEB_ROOT_DIR}')" %>%
                .rpkgweb_qualify() %>% Rscript_call()) +
    make_rule(check_log_path("%"), c(code_desc_path("%"), lib_desc_path("%")),
              paste(check_dir_create_call, run_check_call, sep = "; ") %>%
                Rscript_call()) +
    (
      web %>%
        names %>%
        lapply(. %>% { make_rule(., lib_desc_path(.)) } ) %>%
        make_group(make_comment("Convenience targets"), .dots = .)
    ) +
    (
      web %>%
        names %>%
        lapply(. %>% { make_rule(sprintf("check-%s", .), check_log_path(.)) } ) %>%
        make_group(make_comment("Convenience targets for checking"), .dots = .)
    ) +
    makify_deps(web %>% deps_df)
}

#' @importFrom MakefileR make_rule
makify_deps <- function(y) {
  y <- y %>% subset(internal)
  rules <- mapply(y$package %>% lib_desc_path,
                  y$dep_package %>% lib_desc_path,
                  FUN = make_rule, SIMPLIFY = FALSE)
  Reduce(c, rules, init = make_group(make_comment("Dependencies")))
}

lib_desc_path <- . %>% file.path("${R_USER_LIBRARY}", ., "DESCRIPTION")

.rpkgweb_qualify <- function(expr) {
  paste0(Sys.getenv("RPKGWEB_QUALIFY", "rpkgweb::"), expr)
}

Rscript_call <- function(expr) {
  sprintf("Rscript -e \"%s\"", expr)
}
